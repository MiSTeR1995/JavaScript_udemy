'use strict';

// в этой функции такой синтаксис, что сначала она принимает ту функцию, которая
// должна будет запуститься через опр. промежуток времени. Причем она принимает
// либо объявление функции либо ее название,не вызывается прямо здесь и сейчас
// внутрь этих функций можно также добавить аргументы, а аргументы эти передавать
// как третий аргумент в setTimeOut
// const timerId = setTimeout(function(text) {
//     console.log(text);
// }, 3000, 'Hello');

// можно также передавать готовую функцию, причем вызывать ее не нужно
// const timerId = setTimeout(logger, 2000);

// setTimeOut может работать также и без переменной
// ПРи условии, когда setTImeOut или setInterval передается через переменную, то
// записывается числовой идентификатор этого таймера. Делается для того, чтобы
// определять их для того чтобы  иметь возможность в будущем их как-то останавливать
// clearInterval('тут как раз переменная куда записали таймер');

// clearInterval(timerId); // остановит интервал до его запуска

// для повторений через опр. кол-во времени, для этого используют setInterval

// const btn = document.querySelector('.btn');
// let timerInt;
// let count = 0;
// btn.addEventListener('click', () => {
//     timerInt = setInterval(logger, 1000);
// });

// тут clearinterval не сработает, потому что работает с неопределенностью

// function logger() {

//     // когда таймер сработает 3 раза, очистим интервал
//     if (count === 3){
//         clearInterval(timerInt);
//     }
//     console.log('text');
//     count++;
// }

// могут задать вопрос: чем рекурсивный сеттаймаут лучше чем сет интервал
// сет таймаут может внутри себя вызвать еще один и так далее
// проблема: Когда таймер с интервалом работает, он не учитывает как долго будет
// работать функция внутри него.(сет интервал). Ему все равно сколько будет
// выполняться функция внутри него. Допустим если внутри него тяжелая функция
// которая выполняется дольше чем установленный интервал, он не будет дожидаться
// пока выполнится функция, он ее запустит еще раз
// для избежания таких проблем используют рекурсивный сеттаймаут

// рекурсивный запуст сеттаймаута
// let id = setTimeout(function log() {
//     console.log('hello');
//     id = setTimeout(log, 500);

// }, 500);

// делаем анимацию через таймауты. но анимация сейчас уже создаются в cSS
const btn = document.querySelector('.btn');

btn.addEventListener('click', myAnimation);
function myAnimation() {
    const elem = document.querySelector('.box');
    let position = 0;

    const id = setInterval(frame, 10);
    function frame() {
        // определеяем конец анимации
        // 300 т.к. блок размером 400, а сам квадрат 100, нужно на 300 сместтить
        if (position == 300) {
            clearInterval(id);
        } else {
            position++;
            elem.style.top = position + "px";
            elem.style.left = position + "px";
        }
    }
}
