{"version":3,"sources":["webpack:///./src/js/main.js","webpack:///webpack/bootstrap","webpack:///./src/js/script.js"],"names":[],"mappings":";;;;;;;;;;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,0BAA0B;;;;;;;UC5B1B;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;ACrBA;AACA;AACA,iBAAiB,mBAAO,CAAC,gCAAQ,EAAE;;AAEnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA","file":"bundle.js","sourcesContent":["\r\n// webpack - это сборщик модулей\r\n// как правило, большие проекты состоят из большого количества модулей\r\n// это отдельные js файлы.\r\n\r\n// когда мы хотим собрать все в один скрипт в правильном порядке  - используются несколько подходов\r\n// самое популярное система модулей commonJS и система импортов и экспортов и стандарта ES6\r\n\r\n// работа commonJS\r\n// Такие технологии нужны чтобы не прописывать анонимные функции вручную, а делать это все автоматически\r\n\r\n// Классический пример\r\n// Допустим в одном файле есть функция\r\nfunction myModule() {\r\n    this.hello = function () {\r\n        console.log('hello');\r\n    };\r\n\r\n    this.goodbye = function () {\r\n        console.log('bye');\r\n    };\r\n}\r\n\r\n// чтобы эта функция перешла в другой файл, где ее можно использовать соклько нужно раз\r\n// и применять методы которые нас интересуют\r\n\r\n// следующий синтаксис позволяет это делать\r\n\r\nmodule.exports = myModule; // синтаксис commonJS. помещаем то, что хотим экспортировать\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// чтобы импортировать нужную фукнцию из другого файла, нужно сделать\r\n// Название может быть любое\r\nconst myModule = require('./main'); // расширение можно не ставить, сборщик сам это понимает\r\n\r\n// теперь попробуем использовать функцию\r\n// это функция конструктор, поэтому создаем новую переменную и туда кладем модуль\r\nconst myModuleInstance = new myModule();\r\n\r\n// теперь мы можем смело использовать методы из импортированноо файла\r\nmyModuleInstance.hello();\r\nmyModuleInstance.goodbye();\r\n\r\n// браузер не умеет собиртаь модули самостоятельно!!!\r\n// Ему все равно на экспорты и импорты, он просто выдаст ошибку\r\n// он тупо не знает что такое require()\r\n// Любая модульная система должна быть собрана в один результирующий файл\r\n\r\n// для сборки модулей как раз используем webpack\r\n// она может не только собирать скрипты в кучу, но и конфигурировать проект в целом\r\n// обрабатывать стили, картинки, формировать папки и кучу всего\r\n\r\n// не путать c Gulp. Gulp - это планироващик задач, при помощи него создаются различные таски\r\n// которые будут выполнятся при различных обстаятельствах. Он не умеет собирать  скрипты, обрабатывать изображения итд\r\n// он лишь подключается в себя какие-то модули и запускает определенные задачи\r\n// когда от него это требуют.\r\n\r\n// А вот webpack это сборщик модулей и мы его настраиваем и запускаем его\r\n// чтобы он собирал проект. Они спокойно могут работать вместе\r\n// Например, с помощью Gulp можно запускать WP и это нормальная практика\r\n\r\n// установка WP https://webpack.js.org/guides/getting-started/\r\n\r\n//Сначала создадим каталог, инициализируем npm, установим webpack локально и\r\n// установим webpack-cli (инструмент, используемый для запуска webpack из командной строки)\r\n\r\n// mkdir webpack - demo\r\n// cd webpack - demo\r\n// npm init - y\r\n// npm install webpack webpack - cli--save - dev\r\n\r\n// ЕГо также можно поставить и глобально, чтобы из любой папки брать да собирать\r\n// проект.  Но когда работа идет с реальным проектом то лучше всего ставить ЕГо\r\n// локально, чтобы кто-то другой мог пониммать, что используется вебпек.\r\n\r\n// у вебпека есть два режима работы\r\n// 1) Это использование стандартных настроек, т.е что задано по умолчанию\r\n// 2) Через конфиг и по этим правилам он уже будет работать\r\n\r\n// Когда запускаем без конфига, то уже есть какие-то стандартные настройки\r\n// и нужно от них отталикиваться. см. документацию.\r\n// Главный файл который принимает в себя все импорты должен называться index.js\r\n// и должен находиться строго в папке src. Это главное условие для работы вебпэка без конфига\r\n\r\n// npx webpack - Для запуска вебпэка.\r\n// после этого создается папка dist c файлом main.js\r\n//  это оптимизированная модульная структура, которую мы разбирали в прошлом уроке (070)\r\n// отдельные файлы совместились вместе - при чем это каждый отдельный модуль, со своей локальной областью видимости\r\n\r\n// в реальных проектах обычно используется конфиг для более гибких настроек сборок\r\n// файл webpack.config.js\r\n"],"sourceRoot":""}