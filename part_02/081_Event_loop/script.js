'use strict';

// Событийный цикл (Event loop)

console.log(1);

setTimeout(() => {
    console.log('timeout');
}, 2000);

setTimeout(() => {
    console.log('timeout_4000');
}, 4000);

console.log(2);

// результат вывода: 1 2 tout tout4000 за счет комбинации синхронного и асинхронного кода
// если таймауты с одинаковым таймером, то раньше сработает тот, который был в коде раньше написан

// асинхронные операции
// 1) которые запускаются с течением определенного времени. таймауты и интервалы
// 2) любые запросы на сервер
// 3) все колбеки также являются асинхронными.

// WEB apis хранит колбеки из обработчиков событий, для того чтобы вызвыать в будущем, когда-то ( мы не знаем когда произойдет)
// таймаут тоже туда попадает, она сохраняет также колбек, но его таймер мы знаем
// WEB apis хранилище для асинхронного кода
// из хранилища колбеки попадают в очередь колбеков и если она на первом месте, то выполнится сразу же
// если при ожидании таймаута накликать на кнопку с обработчиком, то каждый клик попадет в очередь и отдалит таймаут
// если у этих кликов также будут таймеры внутри, то они уже будут дожидаться таймер изначальный и потом начнут выполнятся

// суть: все наши действия на странице: клики, обработчики событий, колбеки - все они становятся в очередь, они не могут
// одновременно выполняться.
// когда в колстеке выполняются несколько последовательных функций -  означает что они вложенные (идет выполнение колбека и действий внутри него)

// Важный вывод: Если на странице есть тяжелая задача, которая работает внутри цикла или перебирающего метода, и т.п.
// То она полностью может остановить работу страницы, потому что циклы зависают в колстеке и блокируют очереди на выполнение других функций (клики и тд)
// нужно быть осторожным с тяжелыми скриптами, они могут убить вкладку
// для их решения лучше разбивать тяжелую задачу на несколько частей


// Пример из вопросов на собеседовании
// что выведется первым?
setTimeout (() => {
    console.log(1);
}, 0); // "типо должно сработать сразу"

console.log(2);

// Ответ: 2 1
// Пояснение:
// 1) Чисто программное. Когда запускаем таймаут, он все равно проходит через асинхронную часть и попадает в WebAPI, сначала записывается там, и после этого только идет в очередь колбеков. Если операция будет асинхронная, то первым выполнится в любом случае синхронная(код который дальше)
// 2) Сам язык JS, когда видит 0 в таймауте, либо 1,2,3, то он автоматически меняет значение на 4.
// Сделано это для совместимости между разными браузерами.
// В практике частенько используют костыль, когда используют таймаут с нулем, чтлобы выполнить определенные операции
// после синхронного кода
