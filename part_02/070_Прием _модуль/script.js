'use strict';

// прием модуль - используется для того чтобы скрыть внутренние детали реализации скрипта

// модули по своей структуре самодостаточны и независимы.
// они обеспечивают чистоту глобального пространства
// когда мы просто создаем скрипт и объвляем переменные, то они заносятся
// в глобальную область видимости. Делать это крайне не рекомендуется
// глобальных переменных должно быть как можно меньше
// модули помогут избежать этого, а также конфликтов с одинаковыми именами

// загрязнение глобалнього пространства
// есть два файла, оидн из которых сторонняя библиотека, в которой есть переменная app
// и трогать ее внутри не будем, она разработана сторонне
// при попытке создать в нашем скрипте переменную app и поместить туда какие-то данные
// мы получим ошибку, что переменная уже была объявлена.
// В этом и заключается загряхнение глобального пространства. Какая-то сторонняя
// библиотека создала переменную, которая видна везде, это подобно переменной
// window, которая является глобальной
// именно поэтому рекомендуется меньше работать в глобальном пространстве

// Очень часто мы переносим код из проекта в проекта, инкапсуляция позволяет менять
// внутреннюю реализацию модулей безболезненно и каждый раз можно будет использовать этот код,
// улучшая его под себя

// Сейчас на практике все пользуются классами, но прием модуль был придуман еще до этого

// 1 способ. Анонимная самовызывающаяся функция
const number = 1; // глобально созданная


// внешние круглые скобки нужны чтобы избежать ошибки function declaration (не может быть анонимной)
// Благодаря ним мы получаем function expression - оно как раз таки может не иметь имени
// с помощью такой функции создается собственную область видимости
(function () {// это анонимная самовызывающаяся функция
    let number = 2;
    console.log(number);// 2 - локальная
    console.log(number + 3); // 5 - локальная
} ()); // скобки означают что после объявляния сразу вызывается эта функция

console.log(number); // 1 - уже глобальная


// 2 подход создания модуля. Использование объектного интерфейса
// модуль записывается в переменную и в нее возвращается методы, доступные снаружи

const user = (function() {
    // доступа к ней извне не будет
    const private = function () {
        console.log('I am private');
    };
    // к этой функции доступа нет, но можно использовать объектный интерфейс
    // когда из этой анонимной функции возвращаем объект
    // похожая структура в таймере
    return {
        sayHello: private // ссылка на приватную функцию
    };
} ());

// Мы можем использовать те методы, которые были экспортированны из объектного интерфейса
// по простому: наша анонимная функция создает объект, экспортирует только те методы
// и возможно, те свойства, которые действительно будут нужны снаружи

user.sayHello();

// каждый раз  такие конструкции в качестве анонимных функций врунчную прописывать
// не будем, за нас это будет делать webpack
