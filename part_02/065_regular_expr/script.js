'use strict';

// любое регулярное выражение состоит из двух частей.
// 1 - паттерн(шаблон того, что мы ищем в этой строке итд)
// 2- флаги

// чтобы создать выражение можно пользоваться несколькими синтаксисами
// 1 - конструктор(не используется)
// new RegExp('pattern', 'flags');

// короткая запись самое популярное
// /pattern/f;

// поиск с помощью регулярных выражений
// const ans = prompt('Введите ваше имя');
// найти  маленькие буквы н
const reg = /n/;
// ищется позиция, где встретилось выражение
//если ничего не найдено то вернет -1
// console.log(ans.search(reg)); // внутри строки ищем по регулярному выражению

// найти допустим все буквы, то используют флаги
// 3 классических флага
// 1)  i - если мы хотим что-то найти вне зависимости от регистра
// 2)  g - количество вхождений (несколько вхождений)
// 3)  m - многострочный режим ( когда строки могут быть с переносами)
const reg1 = /n/i;
// console.log(ans.search(reg1));

// флаг g с методом search не работает. Он всегда ищет только первое совпадение
// флаги можно также комбинировать
// match выдает уже массив

// поищем все вхождения с помощью match
const reg2 = /n/ig;
// console.log(ans.match(reg2)); // массив со всеми найденными результатами

// replace - заменяем кусочек строки на другое выражаение
// const pass = prompt('Password');

// // регулярку можно создавать прямо внутри аргументов
// // точка внутри регулярки - берем все элементы, которые попадут в строку
// // чтобы отдельно взять - нужно экранировать. \.
// console.log(pass.replace(/./g, '*')); // все символы заменим на зведочку

// модификация налету
console.log('12-34-56'.replace(/-/g, ':'));

// у регулярок есть и свои методы
const ans = prompt('Введите ваше имя');
const reg4 = /n/ig;
console.log(reg4.test(ans)); // тестим на наличие подобного в строке. либо True либо False

// классы в регулярках:
// \d - ищем цифры
// \w - все слова и буквы
// \s - все пробелы их тоже можно искать внутри выражений

// классический пример
const str = 'My name is R2D2';
// вырезаем имя по шаблону
console.log(str.match(/\w\d\w\d/i)); // сначала ищем конструкцию начинается с буквы, дальше цифра, потом буква, потом цифра


// обратные классы. Иногда нужно найти наоборот не числа, не буквы, не пробелы ...
// \D - не числа
// \W - не буквы
