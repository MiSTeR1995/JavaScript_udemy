'use strict';

// функция по своей сути является объектом и в нее можно записать какие-то
// методы и свойства


// создадим новую функцию с двумя аргументами
// function User(name, id) {

//     // запишем свойство, отображаемое подобно объектам
//     // для каждого конкретного пользователя будем указывать имя и айди
//     // у каждого отдельногоо они будут уникальные
//     this.name = name;
//     this.id = id;

//     // свойство, которое общее для всех
//     this.human = true;

//     // такой синтаксис делает функцию конструктором
//     // с ее помощью мы теперь можем создавать новых пользователей
// }

// таким образом можно создавать новых пользователей
// внутри такой переменный будет лежать уже не функция, а объект
// потому что User стала констркутором, и когда она вызывается при помощи
// ключевого слова New она создает новый объект с теми свойствами, которые
// мы туда записали
const ivan = new User('Ivan', 28);

// можно создать еще один объект
const alex = new User('Alex', 25);

console.log(ivan); // User { name: 'Ivan', id: 28, human: true }
console.log(alex); // User { name: 'Alex', id: 25, human: true }

// такие функции предназначены для конструирования объектов и создания
// множества подобных копий. Подобие прототипа от которого постоянно можно
// создавать потомков. Пример легковые авто: BMW. lada. mers и тд. Они в общем
// похожи, но чем-то различаются

// в таких функция не нужен return
// помимо различных свойств можно записывать методы
ivan.hello();
alex.hello();

function User(name, id) {

    // запишем свойство, отображаемое подобно объектам
    // для каждого конкретного пользователя будем указывать имя и айди
    // у каждого отдельногоо они будут уникальные
    this.name = name;
    this.id = id;

    // свойство, которое общее для всех
    this.human = true;
    this.hello = function () {
        console.log(`Hello ${this.name}`);
    };
}

// также используя свойство протитипа можно добавлять свойства и методы, которые
// прототипно наследуются у потомков. Этот прием используется когда нет доступа
// к нашему прототипу, либо мы его не можем менять по каким-то причинам, но нам
// его нужно модифицировать. добавить например допольнительные приколы


User.prototype.exit = function() {
    console.log(`Пользователь ${this.name} ушел`);
};

// Прототипно будет наследоваться и этот метод
// ! он появиться только всех потом, которые были созданы  после объявления этого метода
//  мы указывам не прототип как это было в setPrototype, когда одно насл. от другого
// а просто добавляем новые свойства или методы в наш объект
ivan.exit();

// Конструкторы нам необходимы для создания новых однотипных объектов
// Например пользователи сайта, товары в магазинах, ролики на ютубе.
// везде где есть шаблонизация, причем даже компоненты сайтов могут так создаваться
// Например есть несколько слайдеров на одной и той же странице, но они разные
// в одном 5, в другом 10, один использует автопереключение, другой нет.
// эти параметры, которые нам необходимы, мы можем задавать как аргументы конструктора
// и потом конструировать слайдер у которого буду одинаковые свойства

// Это все выше было в стандарте ES5: То как это работает под капотом в JS

// В ES6 появились классы: синтаксический сахар (обертка этого функционала)
// их действительно удобнее использовать.
// На данный момент весь реальный функционал создается с испльзованеим классом.


// Это был разбор как это устроено внутри

// Пример классов
class User1 {
    constructor(name, id) {
        this.name = name;
        this.id = id;
        this.human = true;
    }
    hello() {
        console.log(`Hello! ${this.name}`);
    }
    exit() {
        console.log(`Пользователь ${this.name} ушел`);
    }
}
