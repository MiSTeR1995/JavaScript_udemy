'use strict';

// инкапсуляция - это один из принципов ООП
// например, машина, на которой мы любим кататься, но знаниями автомеханика
// мы не владеем. Абсолютно не понимаем из чего состоит и как работает внутри
// но нам это и неважно, мы всегда ее можем сдать в ремонт. Главное что она ездит
// и выполняет свои функции. Так и с программами. Если пользователь просто ее
// использует, то все отлично. Но мы же не хотим чтобы он специально или случайно
// что-то в ней сломал. Точно также и с двигателем, если бы он залез в него и
// вытащил несколько деталей.
// Как раз отделение и сокрытие от внешнего мира внутреностей программы, т.е
// ее переменных, функций и прочего называется ИНКАПСУЛЯЦИЕЙ. В ООП это означает
// что объект хранит свое состояние в приватном порядке. И только методы объекта
// имеют доступ для его изменения. Для чего это? Это защита от вмешательств
// пользователя. Он не сможет залезть внутрь и что-то там поменять. Во-вторых, мы
// всегда без последствий сможем улучшать и дорабатывать программу. Если механик
// установит другую деталь в нашу машину, мы может этого и не заметим.
// В-третьих, это удобно, когда внутренности программы скрыты, а мы используем лишь
// ее результат. Сокрытие информации это распространенная особенность, котоорая
// часто реализуется в других языках программирования как приватные и защищенные
// методы и свойства. Однако в JS можно лишь имитировать нечто подобное.
// Рассмотрим создание инкапсуляции на простом примере. Однако, это довльно сложно
// и лучше понять можно лишь с практикой.

// сначала разберем на функции конструкторе., а потом перейдм на классы
function User(name,age) {
    this.name = name;
    this.age = age;

    this.say = function() {
        console.log(`Имя пользователя: ${this.name}, возраст ${this.age}`);
    };
}


const alex = new User('alex', 25);
// мы спокойно можем обратиться к объекту и получить данные
console.log(alex.name);

// но точно также мы можем их и изменить напрямую
alex.age = 30;
alex.name = 'Alex';

alex.say();

// это то о чем было сказано выше. Любой может вмешаться в работу объекта и
// поменять те значения которые стояли изначально. Произошло вмешательство извне
// и это может сломать работу нашего кода

// Как раз для того чтобы этого не было - нужна инкапсуляция

function User2(name, age) {
    this.name = name;
    // вместо this.age напишем переменную
    // она принимает на себя тот параметр при создании этого объекта
    let userAge = age;

    this.say = function () {
        console.log(`Имя пользователя: ${this.name}, возраст ${userAge}`);
    };
}
const alex2 = new User2('alex', 25);
console.log(alex2.name);
console.log(alex2.age);

// пытаемся поменять напрямую
alex2.age = 30;

alex2.say(); // увидим что возраст никак не поменялся

// дело в том, что внутрио бъекта сидит созданная переменная, которая недоступна
// снаружи. Мы ее не то что поменять, мы ее даже получить не сможем
// потому что это не свойство объекта. Это уже есть зачатки инкапсуляции
// мы свойство userAge сохранили внутри объекта и теперь доступ к нему есть только
// изнутри. Чтобы работать с такими переменными нужно использовать геттеры и сеттеры
// только не тот синтаксис что был в прошлом уроке.
// Так могут называться любые методы, котоорые позволяют либо получать либо устанаваливать значения

// Как раз таки создадим в объекте эти методы. один для получения и второй для изменения
// в этих методах можно также делать множество различных проверок

function User3(name, age) {
    this.name = name;
    // вместо this.age напишем переменную
    // она принимает на себя тот параметр при создании этого объекта
    let userAge = age;

    this.say = function () {
        console.log(`Имя пользователя: ${this.name}, возраст ${userAge}`);
    };
    // теперь благодаря этмоу методу мы сможем обратиться к переменой
    this.getAge = function() {
        return userAge;
    };

    // дадим метод на изменение этого возраста
    this.setAge = function(age) {
        // помимо изменения можно добавлять сюда кучу проверок на входящие данные

        // как вариант проверим на число в пределах
        if (typeof(age) === 'number' && age > 0 && age < 110) {
            // вот только в таком случаем есть возможность его установить
            userAge = age;
        } else {
            console.log(`Недопустимое значение: ${age}!`);
        }
    };
}

const alex3 = new User3('Alex', 25);
console.log(alex3.name);
console.log(alex3.getAge()); // 25

alex3.setAge(30);
alex3.setAge(300); // Недопустимое значение 300!

console.log(alex3.getAge()); // 30
alex3.say(); // Имя пользователя: Alex, возраст 30

// вот теперь благодаря этому наш скрипт более безопасный, к тому же мы можем
// использовать проверки, а доступ снаружи закрыт. Это и есть пример небольшой инкапсуляции



// Теперь посмотрим как это выглядит в классах
class newUser {
    constructor(name, age) {
        this.name = name;

        // если создать переменную внутри конструктора, то доступа к ней
        // внутри нашего класса не будет
        // let userAge = age;

        // только так к ней будет доступ далее. тем самым делая опять ее публичной
        // this.userAge = age;
        // и чтобы показать, что свойство скрыто, нужно использовать такой синтаксис ( начало с нижнего подчеркивания _)
        // это не синтаксис языка. Это соглашение между программистами
        this._age = age;
    }

    // теперь когда пытаемс получить это свойство, то нужно либо геттить либо сеттить
    get age() {
        return this._age;
    }

    set age(age) {

        if (typeof (age) === 'number' && age > 0 && age < 110) {
            this._age = age;
        } else {
            console.log(`Недопустимое значение: ${age}!`);
        }
    }


    say () {
        console.log(`Имя пользователя: ${this.name}, возраст ${this._age}`);
    }
}

const persone = new newUser('Alex', 25);
// console.log(persone.age); // тут мы его геттим
// persone.age = 66; // тут сеттим
// console.log(persone.age); // опять геттим
// persone.say();

// такимо бразом используются свойства аксцессоры для красивого доступа к значению
// а также соблюдаются принципы инкапсуляции

// но есть одна беда, мы по прежнему можем залезть в эти свойства, тем самым обойдя геттеры и сеттеры

console.log(persone._age); // тут мы его геттим
persone._age = 66; // тут сеттим
console.log(persone._age); // опять геттим
persone.say();

// и к сожалению, такая возможность в JS в классах на данный момент остается
// потому что изначально в JS  не планировалось создание классов, они были введены совсем недавно
// если в начале урока мы могли создать инкапсуляцию благодаря функциям и переменным
// то в классах пока это недоступно

// но это относится к офицальным стандартам
// недавно появилась возможность использовать поля классов
// это экспериментальный  синтаксис и пока еще не вошел в стандарт
// он позволяет удобно записывать как свойства так и методы классов


// то что ниже работает пока только в браузере хром
// этот синтаксис позволяет создавать какие-то свойства классов вне конструкторов

class newUser2 {
    constructor(name, age) {
        this.name = name;
        this._age = age;
    }

    // это свойство которое записывается в объект точно также без конструктора
    // это удобно когда необходимо использовать какие-то свойства, которые
    // не будут меняться в зависимости от аргументов, которые приходят в наш класс
    // surname = 'Ax';

    // кроме того , методы в классах можно задавать через функциональные выражения ( стрелочная функция)
    // чтобы не терять контекст в некоторых случаях.
    // и теперь его главная особенность: контекст вызова this будет ссылаться всегда
    // на экземпляр этого объекта
    // но самое главное в таком синтаксисе есть возможность создавать приватные
    // свойства в классах, точно также как возможн ов других языках программиров
    // как в начале урока мы использовали переменную в начале функции конструктора
    // чтобы заприватить переменную используют #
    #surname = 'ax';
    say = () => {
        console.log(`Имя пользователя: ${this.name}${this.#surname}, возраст ${this._age}`);
    }

    get age() {
        return this._age;
    }

    set age(age) {

        if (typeof (age) === 'number' && age > 0 && age < 110) {
            this._age = age;
        } else {
            console.log(`Недопустимое значение: ${age}!`);
        }
    }


}
const persone1 = new newUser2('Alex', 25);
console.log(persone1.surname); // в таком случае мы не достучимся извне
persone1.say();
